---
{
  "title": "201.3: Smart Contract Interactions",
  "slt": ["201.3"],
  "type": "Lesson",
  "description": "Learn to create transactions to redeem assets from smart contracts.",
  "videoURL": "",
  "lastEdited": "2024-01-12",
  "author": "writer: Jingles, editor: Z"
}
---

In 2021, Cardano introduced smart contract support, opening avenues for the development of numerous decentralized applications.

While there are various methods to create a smart contract, this lesson will not go into the creation process.  If you are interested in learning more about this, we recommend you check out [Plutus Project Based Learning](https://gimbalabs.com/pbl) by Gimbalabs. Instead, here you will work with a pre-compiled Plutus smart contract, and we will focus on constructing suitable transactions to interact with it.

## About the smart contract used in this lesson

In this lesson, we shall use a smart contract that was created using [Aiken](https://aiken-lang.org). To be more precise, the 'smart contract' we are using here is really what is called a `validator`, which in this case has the role of ensuring that two conditions are true:

1. the `redeemer` message is "Hello, World!"
2. the transaction is signed by the owner (as specified in the `datum`)

If both conditions are satisfied, the validator 'validates' the transaction i.e. permits the redemption of assets.

The Aiken contract is as defined follows:

```bash
validator {
  fn hello_world(datum: Datum, redeemer: Redeemer, context: ScriptContext) -> Bool {
    let must_say_hello =
      redeemer.msg == "Hello, World!"
 
    let must_be_signed =
      list.has(context.transaction.extra_signatories, datum.owner)
 
    must_say_hello && must_be_signed
  }
}
```

We will build the contract and generate the Plutus blueprint. The blueprint outlines the on-chain contract and its compiled [hexstring representation](https://dencode.com/string/hex). This hexstring will be used in the transactions to interact with the smart contract.

## Part 1: Import the contract with Mesh

With the compiled hexstring, we can create the Mesh `PlutusScript` object. Note that the `PlutusScript` expects the CBOR hexstring to be in the correct format.

```js
export const script: PlutusScript = {
  code: '<CBOR-HEXSTRING-GOES-HERE>'
  version: 'V2',
};
```

To import the compiled Aiken contract, we first need to import the blueprint, which is contained in the file `plutus.json`.

Next we encode the compiled code of the validator using the imported `cbor` functionality. We need to do this first because the validator generated by Aiken is encoded in a "flat" format, which is unfortunately not the same format as that expected by the `cardano-cli` and `cardano serialization library`.

Lastly, we are use the `resolvePlutusScriptAddress` function to resolve (calculate) the script address.

```js
import plutusScript from "plutus.json";
import cbor from "cbor";
import type { PlutusScript } from "@meshsdk/core";

const script: PlutusScript = {
  code: cbor
    .encode(Buffer.from(plutusScript.validators[0].compiledCode, "hex"))
    .toString("hex"),
  version: "V2",
};
const scriptAddress = resolvePlutusScriptAddress(script, 0);
```

## Part 2: Locking assets

We next need to create the transactions that lock assets at the script address:

```js
const hash = resolvePaymentKeyHash((await wallet.getUsedAddresses())[0]);

const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const tx = new Transaction({ initiator: wallet }).sendLovelace(
  {
    address: scriptAddress,
    datum: { value: datum },
  },
  "5000000"
);

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

In the code above we are creating a new transaction to lock assets on the Cardano blockchain. We are using the `resolvePaymentKeyHash` function to resolve (obtain from the address) the payment key hash of the wallet. We are also using the `sendLovelace` function to send lovelace to the script address (1 Ada = 1 million lovelace).

As the contract requires that the owner's address.  Actually, to be more precise, it requires the _key hash_ corresponding to the address to be specified in the datum, and so we are creating a new datum with the public key hash. We are then using the `build` function to build the transaction, the `signTx` function to sign the transaction, and the `submitTx` function to submit the transaction to the Cardano blockchain.

## Part 3: Unlocking assets

Next, we create a transaction to unlock the assets. We create a useful utility function that takes a script address, asset and datum and returns a corresponding utxo.  We use this utility function to retrieve the UTxO of the locked assets (in our case, the 5,000,000 lovelace that were locked in part 2 above).  Note that this is not a fully safe function as it could of course fail in some other cases, but it will serve our purposes for this demo exercise:

```js
async function _getAssetUtxo({ scriptAddress, asset, datum }) {
  const utxos = await koios.fetchAddressUTxOs(scriptAddress, asset);

  const dataHash = resolveDataHash(datum);

  let utxo = utxos.find((utxo: any) => {
    return utxo.output.dataHash == dataHash;
  });

  return utxo;
}
```

Next, we create a transaction to unlock the assets:

```js
const scriptAddress = resolvePlutusScriptAddress(script, 0);

const address = (await wallet.getUsedAddresses())[0];
const hash = resolvePaymentKeyHash(address);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const assetUtxo = await _getAssetUtxo({
  scriptAddress: scriptAddress,
  asset: "lovelace",
  datum: datum,
});
console.log("assetUtxo", assetUtxo);

const redeemer = { data: { alternative: 0, fields: ['Hello, World!'] } };

// create the unlock asset transaction
const tx = new Transaction({ initiator: wallet })
  .redeemValue({
    value: assetUtxo,
    script: script,
    datum: datum,
    redeemer: redeemer,
  })
  .sendValue(address, assetUtxo)
  .setRequiredSigners([address]);

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx, true);
const txHash = await wallet.submitTx(signedTx);
```

So to recap: we have created a new transaction to unlock assets on the Cardano blockchain. We used the `resolvePlutusScriptAddress` function to resolve the script address. We also used the `resolvePaymentKeyHash` function to resolve the payment key hash of the wallet.

As the contract requires the owner's address (actually _payment key hash_ corresponding to the address) in the datum field, we created a new datum containing the payment key hash. We then used the `_getAssetUtxo` function to retrieve the UTxO of the locked assets. Next we used the `redeemValue` function to redeem the locked assets (the lovelace in this case), the `sendValue` function to send the assets to the owner's address, and the `setRequiredSigners` function to set the required signers.

As the validator requires "Hello, World!" as the `redeemer` message, we created a new redeemer containing the message "Hello, World!". We then used the `build` function to build the transaction, the `signTx` function to sign the transaction, and the `submitTx` function to submit the transaction to the Cardano blockchain.

## Full code and demo

You can check out the [full source code](https://github.com/MeshJS/aiken-next-ts-template/blob/main/pages/index.tsx) and [live demo](https://aiken-template.meshjs.dev/) for this lesson.
