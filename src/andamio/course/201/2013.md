---
{
  "title": "201.3: Smart Contract Interactions",
  "slt": ["201.3"],
  "type": "Lesson",
  "description": "Learn to create transactions to redeem assets from smart contracts.",
  "videoURL": "",
  "lastEdited": "2024-01-12",
  "author": "Jingles"
}
---

In 2021, Cardano introduced smart contract support, opening avenues for the development of numerous decentralized applications.

While there are various methods to create a smart contract, this lesson will not delve into the creation process, you can learn more in [Plutus Project Based Learning](https://gimbalabs.com/pbl). Instead, you will work with a compiled Plutus smart contract, focusing on constructing transactions to interact with it.

## About the smart contract used in lesson

In this lesson, we have created the smart contract with Aiken. The validator's role is to verify two conditions: first, it ensures that the redeemer message is "Hello, World!" and second, it confirms that the transaction is signed by the datum's owner. When both conditions are satisfied, the validator permits the redemption of assets.

```bash
validator {
  fn hello_world(datum: Datum, redeemer: Redeemer, context: ScriptContext) -> Bool {
    let must_say_hello =
      redeemer.msg == "Hello, World!"
 
    let must_be_signed =
      list.has(context.transaction.extra_signatories, datum.owner)
 
    must_say_hello && must_be_signed
  }
}
```

We will build the contract and generate the Plutus blueprint, this blueprint outlines the on-chain contract and its compiled hexstring representation. This hexstring will be used for the transactions to interact with the smart contract.

## Part 1: Import the contract with Mesh

With the compiled hexstring, we can create the Mesh `PlutusScript` object. `PlutusScript` expects the CBOR hexstring to be in the correct format.

```js
export const script: PlutusScript = {
  code: '<CBOR-HEXSTRING-HERE>'
  version: 'V2',
};
```

To import the compiled Aiken contract, firstly, we import the blueprint, `plutus.json`.

Then, we are encoding with cbor the compiled code of the validator. This is because the validator generated by Aiken is encoded in a flat format, which is not the format expected by the `cardano-cli` and `cardano serialization library`.

Lastly, we are use the `resolvePlutusScriptAddress` function to resolve the script address.

```js
import plutusScript from "plutus.json";
import cbor from "cbor";
import type { PlutusScript } from "@meshsdk/core";

const script: PlutusScript = {
  code: cbor
    .encode(Buffer.from(plutusScript.validators[0].compiledCode, "hex"))
    .toString("hex"),
  version: "V2",
};
const scriptAddress = resolvePlutusScriptAddress(script, 0);
```

## Part 2: Locking assets

We create the transactions to lock assets on the Cardano blockchain:

```js
const hash = resolvePaymentKeyHash((await wallet.getUsedAddresses())[0]);

const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const tx = new Transaction({ initiator: wallet }).sendLovelace(
  {
    address: scriptAddress,
    datum: { value: datum },
  },
  "5000000"
);

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

Here, we are creating a new transaction to lock assets on the Cardano blockchain. We are using the `resolvePaymentKeyHash` function to resolve the payment key hash of the wallet. We are also using the `sendLovelace` function to send lovelace to the script address.

As the contracts requires the owner's address in the datum field, we are creating a new datum with the owner's address. We are then using the `build` function to build the transaction, the `signTx` function to sign the transaction, and the `submitTx` function to submit the transaction to the Cardano blockchain.

## Part 3: Unlocking assets

Next, we create the transactions to unlock assets. Firstly, we create a useful function to retrieve the UTXO of the locked assets:

```js
async function _getAssetUtxo({ scriptAddress, asset, datum }) {
  const utxos = await koios.fetchAddressUTxOs(scriptAddress, asset);

  const dataHash = resolveDataHash(datum);

  let utxo = utxos.find((utxo: any) => {
    return utxo.output.dataHash == dataHash;
  });

  return utxo;
}
```

Then, we create the transactions to unlock assets:

```js
const scriptAddress = resolvePlutusScriptAddress(script, 0);

const address = (await wallet.getUsedAddresses())[0];
const hash = resolvePaymentKeyHash(address);
const datum: Data = {
  alternative: 0,
  fields: [hash],
};

const assetUtxo = await _getAssetUtxo({
  scriptAddress: scriptAddress,
  asset: "lovelace",
  datum: datum,
});
console.log("assetUtxo", assetUtxo);

const redeemer = { data: { alternative: 0, fields: ['Hello, World!'] } };

// create the unlock asset transaction
const tx = new Transaction({ initiator: wallet })
  .redeemValue({
    value: assetUtxo,
    script: script,
    datum: datum,
    redeemer: redeemer,
  })
  .sendValue(address, assetUtxo)
  .setRequiredSigners([address]);

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx, true);
const txHash = await wallet.submitTx(signedTx);
```

Here, we are creating a new transaction to unlock assets on the Cardano blockchain. We are using the `resolvePlutusScriptAddress` function to resolve the script address. We are also using the `resolvePaymentKeyHash` function to resolve the payment key hash of the wallet.

As the contracts requires the owner's address in the datum field, we are creating a new datum with the owner's address. We are then using the `_getAssetUtxo` function to retrieve the UTXO of the locked assets. We are then using the `redeemValue` function to redeem the locked assets, the `sendValue` function to send the assets to the owner's address, and the `setRequiredSigners` function to set the required signers.

As the validator requires `Hello, World!` as the redeemer message, we are creating a new redeemer with the message `Hello, World!`. We are then using the `build` function to build the transaction, the `signTx` function to sign the transaction, and the `submitTx` function to submit the transaction to the Cardano blockchain.

## Full code and demo

You can check out the [full source code](https://github.com/MeshJS/aiken-next-ts-template/blob/main/pages/index.tsx) and [live demo](https://aiken-template.meshjs.dev/) for this lesson.
