---
{
  "title": "202.1: MeshTxBuilder - Introduction & Send Lovelace",
  "slt": ["202.1"],
  "type": "Lesson",
  "description": "I can build a transaction to send lovelace using lower level transaction APIs.",
  "videoURL": "",
  "lastEdited": "19 Apr 2024",
  "author": "Write: Leon, Review: Hinson",
}
---

## Introduction

In the [Course 200.1](/course/module/200/2001) of the Transactions Instance module, you have learned how to build a transaction to send lovelaces using the Mesh Transaction Instance which you will imitate and build a similar transaction using the lower level transaction APIs provided by MeshTxBuilder in this lesson. As the first module of `MeshTxBuilder`, here we will cover both building transaction with wallet instance and purely from application backend.

---

### Step 1: Setting up the MeshTxBuilder instance

To start building customized transactions using `MeshTxBuilder`, you have to initialize a `MeshTxBuilder` instance with a [Cardano APIs Provider](https://meshjs.dev/providers), such as [Maestro](https://meshjs.dev/providers/maestro) in the following case.

```typescript
import { MaestroProvider, MeshTxBuilder } from "@meshsdk/core";
import { useWallet } from "@meshsdk/react";

const maestro = new MaestroProvider({
  network: "Preprod",
  apiKey: YOUR_MAESTRO_API_KEY,
});

const Course2021 = () => {
  const { wallet } = useWallet();

  const mesh = new MeshTxBuilder({
    fetcher: maestro,
    submitter: wallet, // or maestro
    evaluator: maestro,
  });

  return <></>;
};

export default Course2021;
```

You can pass in 4 optional fields to the `MeshTxBuilder` constructor to customize your instance according to your project. They are

- `fetcher`: In type `IFetcher`, to fetch information from the blockchain and complete transaction information if not fully provided (i.e. `txIn` when no address and value, `fetcher` instance help you complete the missing information).
- `submitter`: In type `ISubmitter`, where you want to submit transaction to.
- `evaluator`: In type `IEvaluator`, for evaluating if transaction is valid and redeemer execution unit optimization after build
- `isHydra`: A `boolean`, to use another set of default protocol parameters for transactions building

You can initialize the instance with the `maestro` provider and browser wallet as submitter for now as shown in the example above.

---

### Step 2: Get the UTxOs of the Sender's Address

To build a transaction to send fund, you have to find the UTxOs with enough lovelaces to be used to cover the amount and fee incurred. Let's start with an example where you want to send fund from your browser wallet.

Here is an example on how to do it:

```typescript
const getUtxosWithMinLovelace = async (lovelace: number) => {
  const utxos: UTxO[] = await wallet.getUtxos();
  return utxos.filter((utxo) => {
    const lovelaceAmount = utxo.output.amount.find(
      (asset: any) => asset.unit === "lovelace"
    )?.quantity;
    return Number(lovelaceAmount) > lovelace;
  });
};
```

The function fetches the UTxOs from your browser wallet, then it filters out the UTxOs that are lovelace and have quantity greater than the required amount.

---

### Step 3.1: Building a Transaction to Send Fund by Browser Wallet

Now you can start building the transaction to send fund. Here is an example on how to do it:

```typescript
const sendFund = async () => {
  const utxos = await getUtxosWithMinLovelace(10000000);
  const { input, output } = utxos[0];
  const { txHash: txInHash, outputIndex: txInId } = input;
  const { address: txInAddress, amount: txInAmount } = output;
  await mesh
    .txIn(txInHash, txInId, txInAmount, txInAddress)
    .txOut(RECIPIENT_ADDRESS, [{ unit: "lovelace", quantity: "5000000" }])
    .changeAddress(RECIPIENT_ADDRESS)
    .complete();

  const signedTx = await wallet.signTx(mesh.txHex);
  const txHash = await mesh.submitTx(signedTx);
  console.log("txHash", txHash);
};
```

In the provided code, you called the function created in the previous step to get the UTxOs with adequate lovelace. Then, you can use the first UTxO in the acquired array to set the input for the transaction in `txIn`. Consequently, you can set the output of the transaction in `txOut` with your recipient's address and the amount of lovelace you would like to send. You also have to configure the `changeAddress` to accept change UTxO from the transaction. Finally. you can use `complete` to finish building the transaction where the `MeshTxBuilder` instance will analyze and serialize the transaction if it is valid.

After that, you can use the method from browser wallet to sign the transaction, then it could be submitted to the blockchain using `submitTx`.

---

### Step 3.2: Building a Transaction to Send Fund by Wallet Generated by CLI

It is very similar to above for building a transaction to send fund by wallet generated by CLI like below:

```sh
cardano-cli address key-gen \
--verification-key-file wallet.vkey \
--signing-key-file wallet.skey
```

In this type of transaction, there are 2 points which are different:

1. Fetching UTxO - we need to get the UTxO information from a fetcher
2. Signing Transaction - `MeshTxBuilder` supports signing transaction natively through endpoint `.signingKey()` with `.completeSigning()`.

```typescript
const getUtxosWithMinLovelace = async (lovelace: number) => {
  const utxos: UTxO[] = await maestro.fetchAddressUTxOs(
    YOUR_WALLET_ADDRESS_HOLDING_ASSETS
  ); // Difference here
  return utxos.filter((utxo) => {
    const lovelaceAmount = utxo.output.amount.find(
      (asset: any) => asset.unit === "lovelace"
    )?.quantity;
    return Number(lovelaceAmount) > lovelace;
  });
};

const sendFund = async () => {
  const utxos = await getUtxosWithMinLovelace(10000000);
  const { input, output } = utxos[0];
  const { txHash: txInHash, outputIndex: txInId } = input;
  const { address: txInAddress, amount: txInAmount } = output;
  await mesh
    .txIn(txInHash, txInId, txInAmount, txInAddress)
    .txOut(RECIPIENT_ADDRESS, [{ unit: "lovelace", quantity: "5000000" }])
    .changeAddress(RECIPIENT_ADDRESS)
    .signingKey(YOUR_PRIVATE_KEY_HEX) // Add signing key for your transaction (i.e. wallet.skey generated by cli above)
    .complete();

  const signedTx = mesh.completeSigning(); // Sign you transaction here
  const txHash = await mesh.submitTx(signedTx);
  console.log("txHash", txHash);
};
```

---

### Step 4: Run and Test your Code

The complete code should be something like the following example:

```typescript
import { MaestroProvider, MeshTxBuilder, UTxO } from "@meshsdk/core";
import { useAddress } from "@meshsdk/react";

const Course2021 = () => {
  const address = useAddress();

  const maestro = new MaestroProvider({
    network: "Preprod",
    apiKey: YOUR_MAESTRO_API_KEY,
  });

  const mesh = new MeshTxBuilder({
    fetcher: maestro,
    submitter: maestro,
    evaluator: maestro,
  });

  const getUtxosWithMinLovelace = async (lovelace: number) => {
    let utxos: UTxO[] = await maestro.fetchAddressUTxOs(address!);
    return utxos.filter((utxo) => {
      const lovelaceAmount = utxo.output.amount.find(
        (asset: any) => asset.unit === "lovelace"
      )?.quantity;
      return Number(lovelaceAmount) > lovelace;
    });
  };

  const sendFund = async () => {
    const utxos = await getUtxosWithMinLovelace(10000000);
    const txInHash = utxos[0].input.txHash;
    const txInId = utxos[0].input.outputIndex;
    await mesh
      .txIn(txInHash, txInId)
      .txOut(address!, [{ unit: "lovelace", quantity: "5000000" }])
      .changeAddress(address!)
      .signingKey("your_signing_key")
      .complete();

    const signedTx = mesh.completeSigning();

    const txHash = await mesh.submitTx(signedTx);

    console.log("txHash", txHash);
  };

  return (
    <div className="p-3">
      <button className="m-2 p-2 bg-slate-500" onClick={sendFund}>
        Send Fund To Self
      </button>
    </div>
  );
};

export default Course2021;
```

Now run the application with `npm run dev` and open a browser, go to the URL `http://localhost:3000`. You will see a `Send Fund To Self` button. It should build a transaction to send fund to the address of the wallet currently connected when clicked.

You can modify the code examples in this module according to your project ideas. Feel free to make modifications and create something different while applying the same principles from code example above to practice your skills as a developer.

---
